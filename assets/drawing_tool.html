<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Drawing Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Prevent body scrollbars when canvas is panned */
        }
        .container {
            max-width: 1200px;
            width: 100%;
            padding: 20px;
            text-align: center;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #7f8c8d;
            margin-bottom: 20px;
        }
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .tool-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .tool-button:hover {
            background-color: #2980b9;
        }
        .tool-button.active {
            background-color: #2980b9;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3) inset;
        }
        .canvas-container {
            position: relative;
            border: 2px solid #2c3e50;
            overflow: hidden;
            background-color: #fff; /* Added a background to canvas container for better visual */
            min-width: 800px;
            min-height: 600px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #drawing-canvas {
            cursor: crosshair;
            display: block;
            position: relative;
            z-index: 10;
            pointer-events: auto;
        }
        .status-bar {
            margin-top: 10px;
            color: #00bcd4;
            font-size: 14px;
            text-align: center;
        }
        .snap-controls {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 15px;
            justify-content: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked+.slider {
            background-color: #2196F3;
        }
        input:checked+.slider:before {
            transform: translateX(26px);
        }
        .coordinates {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            z-index: 15;
        }
        .snap-label {
            font-weight: bold;
        }
        .snap-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .snap-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .snap-option label {
            font-size: 14px;
        }
        .fillet-controls {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 15px;
            justify-content: center;
        }
        .fillet-radius {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .selected-path {
            stroke: #ff9800 !important;
            stroke-width: 3px !important; /* Consider scaling this with viewScale or keep screen fixed */
        }
        .coord-input-container {
            display: none;
            margin-top: 10px;
            gap: 10px;
            justify-content: center;
        }
        .coord-input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80px;
        }
        .coord-submit {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .coord-submit:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DRAW</h1>
        <p class="subtitle">Edit and draw the map.</p>
        <div class="toolbar">
            <button class="tool-button" id="line-tool">‚úèÔ∏èLINE</button>
            <button class="tool-button" id="polyline-tool">üìèPOLYLINE</button>
            <button class="tool-button" id="arc-tool">üß≤ARC</button>
            <button class="tool-button" id="spline3-tool">üìàSPLINE 3</button>
            <button class="tool-button" id="spline5-tool">üìâSPLINE 5</button>
            <button class="tool-button" id="fillet-tool">üîÑFILLET</button>
            <button class="tool-button" id="save-tool">üíæSAVE</button>
            <button class="tool-button" id="clear-tool">üßπCLEAR</button>
            <button class="tool-button" id="clear-data-tool">üóëÔ∏èCLEAR DATA</button>
            <button class="tool-button" id="zoom-in-tool">üîç+</button>
            <button class="tool-button" id="zoom-out-tool">üîç-</button>
            <button class="tool-button" id="reset-view-tool">üñºÔ∏èRESET</button>
        </div>
        <div class="fillet-controls" id="fillet-controls" style="display: none;">
            <span class="snap-label">Fillet Radius:</span>
            <input type="number" id="fillet-radius" class="fillet-radius" value="1" min="0.1" step="0.1">
            <span class="snap-label">(Select two connected lines)</span>
        </div>
        <div class="snap-controls">
            <div class="snap-option">
                <span class="snap-label">Auto-Snap:</span>
                <label class="switch">
                    <input type="checkbox" id="snap-toggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="snap-options">
                <div class="snap-option">
                    <input type="checkbox" id="snap-endpoint" checked>
                    <label for="snap-endpoint">Endpoint</label>
                </div>
                <div class="snap-option">
                    <input type="checkbox" id="snap-midpoint">
                    <label for="snap-midpoint">Midpoint</label>
                </div>
                <div class="snap-option">
                    <input type="checkbox" id="snap-intersection">
                    <label for="snap-intersection">Intersection</label>
                </div>
                <div class="snap-option">
                    <input type="checkbox" id="snap-grid">
                    <label for="snap-grid">Grid</label>
                </div>
            </div>
            <div class="snap-option">
                <span class="snap-label">Enter Coordinates:</span>
                <label class="switch">
                    <input type="checkbox" id="coord-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="snap-option">
                <span class="snap-label">Ortho X/Y:</span>
                <label class="switch">
                    <input type="checkbox" id="ortho-toggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        <div class="coord-input-container" id="coord-input-container"></div>
        
        <div class="canvas-container">
            <canvas id="drawing-canvas"></canvas>
            <div class="coordinates" id="coordinates">0, 0</div>
        </div>
        <div class="status-bar" id="status-bar">The map is ready for your work.</div>
    </div>
    <script>
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const coordsDisplay = document.getElementById('coordinates');
        const statusBar = document.getElementById('status-bar');
        const filletControls = document.getElementById('fillet-controls');
        const canvasContainer = document.querySelector('.canvas-container');
        const coordInputContainer = document.getElementById('coord-input-container');

        const mapImage = new Image();
        mapImage.src = '/static/map_image.png';
        mapImage.onload = () => {
            console.log('Map image loaded');
            if (typeof render === 'function') render(); // Ensure render is defined
        };
        mapImage.onerror = () => {
            console.error('Failed to load map image');
            statusBar.textContent = 'Failed to load map image.';
        };

        let mapWidth = 400;
        let mapHeight = 400;
        let resolution_x = 0.05;
        let resolution_y = 0.05;
        let origin_x = 0.0;
        let origin_y = 0.0;

        let viewScale = 1.0; 
        let viewOffsetX = 0; 
        let viewOffsetY = 0; 
        let initialViewScale, initialViewOffsetX, initialViewOffsetY;

        const MIN_ZOOM = 0.02;
        const MAX_ZOOM = 200;
        const ZOOM_SENSITIVITY = 1.1;

        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };


        fetch('/home/duc/Downloads/MIR100_WebApp/static/map_image.json')
            .then(response => {
                if (!response.ok) throw new Error('Failed to load map_image.json');
                return response.json();
            })
            .then(data => {
                console.log('JSON data:', data);
                mapWidth = data.width || 400;
                mapHeight = data.height || 400;
                resolution_x = data.resolution_x || data.resolution || 0.05000000074505806;
                resolution_y = data.resolution_y || data.resolution || 0.05000000074505806;
                origin_x = data.origin_x || 0.0;
                origin_y = data.origin_y || 0.0;
                initCanvasSize(); 
                init();
            })
            .catch(error => {
                console.error('Error loading map image JSON:', error);
                statusBar.textContent = 'Failed to load map parameters, using defaults.';
                initCanvasSize();
                init();
            });

        function initCanvasSize() {
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            console.log('Canvas element size set to:', canvas.width, canvas.height);
        }

        function setupInitialView() {
            const mapDisplayWidthMeters = mapWidth * resolution_x;
            const mapDisplayHeightMeters = mapHeight * resolution_y;

            const PADDING = 50; 

            const availableWidthForMap = canvas.width - 2 * PADDING;
            const availableHeightForMap = canvas.height - 2 * PADDING;

            if (mapDisplayWidthMeters <= 0 || mapDisplayHeightMeters <= 0 || availableWidthForMap <=0 || availableHeightForMap <=0) {
                initialViewScale = 20; 
                initialViewOffsetX = PADDING;
                initialViewOffsetY = canvas.height - PADDING;
                console.warn("Invalid map/canvas dimensions for initial view setup, using defaults.");
            } else {
                const scaleX = availableWidthForMap / mapDisplayWidthMeters;
                const scaleY = availableHeightForMap / mapDisplayHeightMeters;
                initialViewScale = Math.min(scaleX, scaleY);
            }
            
            initialViewScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, initialViewScale));

            const mapScaledWidth = mapDisplayWidthMeters * initialViewScale;
            const mapScaledHeight = mapDisplayHeightMeters * initialViewScale;

            initialViewOffsetX = PADDING + (availableWidthForMap - mapScaledWidth) / 2;
            initialViewOffsetY = canvas.height - PADDING - (availableHeightForMap - mapScaledHeight) / 2;
            
            resetView(false); 
            console.log(`Initial view: scale=${viewScale}, offsetX=${viewOffsetX}, offsetY=${viewOffsetY}`);
        }

        function resetView(doRender = true) {
            viewScale = initialViewScale;
            viewOffsetX = initialViewOffsetX;
            viewOffsetY = initialViewOffsetY;
            if (doRender && typeof render === 'function') render();
        }

        function canvasToGrid(canvasX, canvasY) {
            const gridX = (canvasX - viewOffsetX) / viewScale + origin_x;
            const gridY = (viewOffsetY - canvasY) / viewScale + origin_y;
            return { x: gridX, y: gridY };
        }

        function gridToCanvas(gridX, gridY) {
            const canvasX = (gridX - origin_x) * viewScale + viewOffsetX;
            const canvasY = viewOffsetY - (gridY - origin_y) * viewScale;
            return { x: canvasX, y: canvasY };
        }
        
        // Main init function
        function init() {
            setupInitialView(); 

            const tools = document.querySelectorAll('.tool-button');
            let activeTool = 'line-tool';
            let drawing = false;
            let currentPath = [];
            let allPaths = [];
            let tempPoint = null;
            let snapPoint = null;
            let selectedPaths = [];
            let orthoMode = false;
            let isCoordMode = false;

            const orthoToggle = document.getElementById('ortho-toggle');
            orthoToggle.addEventListener('change', () => {
                orthoMode = orthoToggle.checked;
                if (orthoMode && isCoordMode) {
                    coordToggle.checked = false;
                    isCoordMode = false;        
                    canvas.style.pointerEvents = 'auto';
                    hideCoordInput();
                    statusBar.textContent = "Ortho mode enabled. Coordinate input disabled.";
                } else if (orthoMode) {
                    statusBar.textContent = "Ortho mode enabled.";
                } else {
                    statusBar.textContent = "Ortho mode disabled.";
                }
                render();
            });

            const coordToggle = document.getElementById('coord-toggle');
            coordToggle.addEventListener('change', () => {
                isCoordMode = coordToggle.checked;
                if (isCoordMode) { 
                    canvas.style.pointerEvents = 'none';
                    showCoordInput();
                    if (orthoMode) { 
                        orthoMode = false; 
                        orthoToggle.checked = false;
                        statusBar.textContent = "Coordinate input enabled. Ortho mode disabled.";
                    }
                } else { 
                    canvas.style.pointerEvents = 'auto';
                    hideCoordInput();
                }
                render();
            });


            function drawMapImage() {
                if (mapImage.complete && mapImage.naturalWidth !== 0) {
                    const mapGridWidthMeters = mapWidth * resolution_x;
                    const mapGridHeightMeters = mapHeight * resolution_y;
            
                    const mapImageTopLeftGridX = origin_x;
                    const mapImageTopLeftGridY = origin_y + mapGridHeightMeters; 
            
                    const mapTopLeftCanvas = gridToCanvas(mapImageTopLeftGridX, mapImageTopLeftGridY);
            
                    const mapDisplayWidthCanvas = mapGridWidthMeters * viewScale;
                    const mapDisplayHeightCanvas = mapGridHeightMeters * viewScale;
            
                    ctx.drawImage(
                        mapImage,
                        mapTopLeftCanvas.x,
                        mapTopLeftCanvas.y,
                        mapDisplayWidthCanvas,
                        mapDisplayHeightCanvas
                    );
                }
            }

            function drawGrid() {
                drawMapImage(); 
                
                const baseGridLineWidth = 0.5;
                const dynamicGridLineWidth = Math.max(0.1, Math.min(1.0, baseGridLineWidth / viewScale));
                ctx.lineWidth = dynamicGridLineWidth;
                ctx.strokeStyle = 'rgba(224, 224, 224, 0.3)';

                const gridSpacingMeters = 1;
                const { x: viewMinX_grid, y: viewMaxY_grid } = canvasToGrid(0, 0);
                const { x: viewMaxX_grid, y: viewMinY_grid } = canvasToGrid(canvas.width, canvas.height);

                let firstGridLineX = Math.floor(viewMinX_grid / gridSpacingMeters) * gridSpacingMeters;
                for (let gx = firstGridLineX; gx <= viewMaxX_grid + gridSpacingMeters; gx += gridSpacingMeters) {
                    const { x: canvasX } = gridToCanvas(gx, 0);
                    ctx.beginPath();
                    ctx.moveTo(canvasX, 0);
                    ctx.lineTo(canvasX, canvas.height);
                    ctx.stroke();
                }

                let firstGridLineY = Math.floor(viewMinY_grid / gridSpacingMeters) * gridSpacingMeters;
                for (let gy = firstGridLineY; gy <= viewMaxY_grid + gridSpacingMeters; gy += gridSpacingMeters) {
                    const { y: canvasY } = gridToCanvas(0, gy);
                    ctx.beginPath();
                    ctx.moveTo(0, canvasY);
                    ctx.lineTo(canvas.width, canvasY);
                    ctx.stroke();
                }

                const baseAxisLineWidth = 1.0;
                const dynamicAxisLineWidth = Math.max(0.2, Math.min(1.5, baseAxisLineWidth / viewScale));
                ctx.lineWidth = dynamicAxisLineWidth;
                ctx.strokeStyle = 'rgba(160, 160, 160, 0.5)';
                
                const yAxisCanvasX = gridToCanvas(origin_x, 0).x;
                ctx.beginPath();
                ctx.moveTo(yAxisCanvasX, 0);
                ctx.lineTo(yAxisCanvasX, canvas.height);
                ctx.stroke();

                const xAxisCanvasY = gridToCanvas(0, origin_y).y;
                ctx.beginPath();
                ctx.moveTo(0, xAxisCanvasY);
                ctx.lineTo(canvas.width, xAxisCanvasY);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(102, 102, 102, 0.7)';
                ctx.font = '12px Arial';
                const labelSpacingMeters = (viewScale < 0.5) ? 20 : (viewScale < 2 ? 10 : (viewScale < 10 ? 5 : 1)); 

                let firstLabelX = Math.floor(viewMinX_grid / labelSpacingMeters) * labelSpacingMeters;
                for (let gx = firstLabelX; gx <= viewMaxX_grid + labelSpacingMeters; gx += labelSpacingMeters) {
                    if (gx < origin_x && Math.abs(gx - origin_x) > 1e-3 && Math.abs(gx) > 1e-3) continue;
                    const canvasCoords = gridToCanvas(gx, origin_y);
                    if (canvasCoords.x > -20 && canvasCoords.x < canvas.width + 20 && canvasCoords.y > -10 && canvasCoords.y < canvas.height + 20) {
                        ctx.fillText(gx.toFixed(0), canvasCoords.x + 5, canvasCoords.y + 15);
                    }
                }
                let firstLabelY = Math.floor(viewMinY_grid / labelSpacingMeters) * labelSpacingMeters;
                for (let gy = firstLabelY; gy <= viewMaxY_grid + labelSpacingMeters; gy += labelSpacingMeters) {
                    if (gy < origin_y && Math.abs(gy - origin_y) > 1e-3 && Math.abs(gy) > 1e-3) continue;
                    const canvasCoords = gridToCanvas(origin_x, gy);
                     if (canvasCoords.y > -10 && canvasCoords.y < canvas.height + 10 && canvasCoords.x > -30 && canvasCoords.x < canvas.width + 30) {
                        ctx.fillText(gy.toFixed(0), canvasCoords.x - 25, canvasCoords.y - 5);
                    }
                }
            }


            function findSnapPoint(x, y) { 
                if (!document.getElementById('snap-toggle').checked || isCoordMode) return null;
                const snapRadiusCanvas = 10; 
                const mousePoint = { x, y };
                let closestPoint = null; 
                let minDistance = snapRadiusCanvas;

                if (document.getElementById('snap-grid').checked) {
                    const gridSpacingMeters = 1; 
                    const mouseGridCoords = canvasToGrid(x, y);
                    const snappedGridX_meters = Math.round(mouseGridCoords.x / gridSpacingMeters) * gridSpacingMeters;
                    const snappedGridY_meters = Math.round(mouseGridCoords.y / gridSpacingMeters) * gridSpacingMeters;
                    const snappedCanvasPoint = gridToCanvas(snappedGridX_meters, snappedGridY_meters);
                    
                    const gridDist = Math.sqrt(Math.pow(snappedCanvasPoint.x - x, 2) + Math.pow(snappedCanvasPoint.y - y, 2));
                    if (gridDist < minDistance) {
                        minDistance = gridDist;
                        closestPoint = { x: snappedCanvasPoint.x, y: snappedCanvasPoint.y, type: 'grid' };
                    }
                }
                if (document.getElementById('snap-endpoint').checked) {
                    allPaths.forEach(path => {
                        if (path.points.length > 0) {
                            const firstPoint = path.points[0]; 
                            const distFirst = Math.sqrt(Math.pow(firstPoint.x - mousePoint.x, 2) + Math.pow(firstPoint.y - mousePoint.y, 2));
                            if (distFirst < minDistance) {
                                minDistance = distFirst;
                                closestPoint = { x: firstPoint.x, y: firstPoint.y, type: 'endpoint' };
                            }
                            const lastPoint = path.points[path.points.length - 1];
                            const distLast = Math.sqrt(Math.pow(lastPoint.x - mousePoint.x, 2) + Math.pow(lastPoint.y - mousePoint.y, 2));
                            if (distLast < minDistance) {
                                minDistance = distLast;
                                closestPoint = { x: lastPoint.x, y: lastPoint.y, type: 'endpoint' };
                            }
                        }
                    });
                }
                if (document.getElementById('snap-midpoint').checked) {
                    allPaths.forEach(path => {
                        if (path.type === 'line' && path.points.length >= 2) {
                            for (let i = 0; i < path.points.length - 1; i++) {
                                const p1 = path.points[i]; const p2 = path.points[i + 1];
                                const midX = (p1.x + p2.x) / 2; const midY = (p1.y + p2.y) / 2;
                                const distMid = Math.sqrt(Math.pow(midX - mousePoint.x, 2) + Math.pow(midY - mousePoint.y, 2));
                                if (distMid < minDistance) {
                                    minDistance = distMid;
                                    closestPoint = { x: midX, y: midY, type: 'midpoint' };
                                }
                            }
                        }
                    });
                }
                if (document.getElementById('snap-intersection').checked) {
                     for (let i = 0; i < allPaths.length; i++) {
                        for (let j = i + 1; j < allPaths.length; j++) {
                            if (allPaths[i].type === 'line' && allPaths[j].type === 'line') {
                                for (let pi = 0; pi < allPaths[i].points.length - 1; pi++) {
                                    for (let pj = 0; pj < allPaths[j].points.length - 1; pj++) {
                                        const line1 = { x1: allPaths[i].points[pi].x, y1: allPaths[i].points[pi].y, x2: allPaths[i].points[pi+1].x, y2: allPaths[i].points[pi+1].y };
                                        const line2 = { x1: allPaths[j].points[pj].x, y1: allPaths[j].points[pj].y, x2: allPaths[j].points[pj+1].x, y2: allPaths[j].points[pj+1].y };
                                        const intersection = findLineIntersection(line1, line2);
                                        if (intersection) {
                                            const distIntersection = Math.sqrt(Math.pow(intersection.x - mousePoint.x, 2) + Math.pow(intersection.y - mousePoint.y, 2));
                                            if (distIntersection < minDistance) {
                                                minDistance = distIntersection;
                                                closestPoint = { x: intersection.x, y: intersection.y, type: 'intersection' };
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return closestPoint;
            }

            function findLineIntersection(line1, line2) {
                const x1 = line1.x1, y1 = line1.y1, x2 = line1.x2, y2 = line1.y2;
                const x3 = line2.x1, y3 = line2.y1, x4 = line2.x2, y4 = line2.y2;
                const denominator = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
                if (denominator === 0) return null;
                const ua = (((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3))) / denominator;
                const ub = (((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3))) / denominator;
                if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                    const x = x1 + (ua * (x2 - x1));
                    const y = y1 + (ua * (y2 - y1));
                    return { x, y };
                }
                return null;
            }

            function distanceToLineSegment(point, line) {
                const { x, y } = point;
                const { x1, y1, x2, y2 } = line;
                const A = x - x1; const B = y - y1; const C = x2 - x1; const D = y2 - y1;
                const dot = A * C + B * D; const len_sq = C * C + D * D;
                let param = -1; if (len_sq !== 0) param = dot / len_sq;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                const dx = x - xx; const dy = y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function findNearestLine(x, y) {
                const mousePoint = { x, y };
                let closestDist = Infinity; let closestPath = null; let closestSegmentIndex = -1;
                allPaths.forEach((path, pathIndex) => {
                    if (path.type === 'line' && path.points.length >= 2) {
                        for (let i = 0; i < path.points.length - 1; i++) {
                            const p1 = path.points[i]; const p2 = path.points[i + 1];
                            const line = { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y };
                            const dist = distanceToLineSegment(mousePoint, line);
                            if (dist < closestDist && dist < 10) { 
                                closestDist = dist;
                                closestPath = path;
                                closestPath.index = pathIndex;
                                closestSegmentIndex = i;
                            }
                        }
                    }
                });
                return closestPath ? { path: closestPath, segmentIndex: closestSegmentIndex } : null;
            }

            function findCommonPoint(line1, line2) {
                for (let i = 0; i < line1.points.length; i++) {
                    for (let j = 0; j < line2.points.length; j++) {
                        const p1 = line1.points[i]; const p2 = line2.points[j];
                        if (Math.abs(p1.x - p2.x) < 0.001 && Math.abs(p1.y - p2.y) < 0.001) { 
                            return { point: p1, index1: i, index2: j };
                        }
                    }
                }
                return null;
            }

            function calculateFillet() {
                if (selectedPaths.length !== 2) return null;
                const selectedLine1Info = selectedPaths[0];
                const selectedLine2Info = selectedPaths[1];
                const line1 = selectedLine1Info.path;
                const line2 = selectedLine2Info.path;

                const commonPointInfo = findCommonPoint(line1, line2);
                if (!commonPointInfo) {
                    statusBar.textContent = "Selected lines don't share a corner point!";
                    return null;
                }
                const { point: corner, index1, index2 } = commonPointInfo; 

                const p1 = index1 === 0 ? (line1.points.length > 1 ? line1.points[1] : null) : line1.points[index1 - 1];
                const p2 = index2 === 0 ? (line2.points.length > 1 ? line2.points[1] : null) : line2.points[index2 - 1];

                if (!p1 || !p2) {
                     statusBar.textContent = "Cannot determine fillet segments (line too short).";
                     return null;
                }

                const v1 = { x: p1.x - corner.x, y: p1.y - corner.y };
                const v2 = { x: p2.x - corner.x, y: p2.y - corner.y };
                const len1_canvas = Math.hypot(v1.x, v1.y);
                const len2_canvas = Math.hypot(v2.x, v2.y);

                if (len1_canvas < 1e-6 || len2_canvas < 1e-6) {
                     statusBar.textContent = "Fillet segments are too short.";
                     return null;
                }

                const n1 = { x: v1.x / len1_canvas, y: v1.y / len1_canvas };
                const n2 = { x: v2.x / len2_canvas, y: v2.y / len2_canvas };
                let cosTheta = n1.x * n2.x + n1.y * n2.y;
                cosTheta = Math.max(-1, Math.min(1, cosTheta));
                const theta = Math.acos(cosTheta);

                if (Math.abs(theta) < 1e-6 || Math.abs(theta - Math.PI) < 1e-6) {
                    statusBar.textContent = "Lines are collinear, cannot fillet.";
                    return null;
                }

                const radiusValueMeters = parseFloat(document.getElementById('fillet-radius').value);
                if (isNaN(radiusValueMeters) || radiusValueMeters <=0) {
                     statusBar.textContent = "Invalid fillet radius.";
                     return null;
                }
                const radiusCanvas = radiusValueMeters * viewScale; 

                const tanHalfTheta = Math.tan(theta / 2);
                if (Math.abs(tanHalfTheta) < 1e-9) {
                    statusBar.textContent = "Angle too small for fillet calculation.";
                    return null;
                }
                const tangentDistCanvas = radiusCanvas / tanHalfTheta;

                if (tangentDistCanvas > len1_canvas || tangentDistCanvas > len2_canvas) {
                    statusBar.textContent = "Fillet radius too large for segment lengths.";
                    return null;
                }

                const p1Trim = { x: corner.x + n1.x * tangentDistCanvas, y: corner.y + n1.y * tangentDistCanvas };
                const p2Trim = { x: corner.x + n2.x * tangentDistCanvas, y: corner.y + n2.y * tangentDistCanvas };
                
                return {
                    line1Data: { ...line1, newEndPoint: p1Trim, cornerIndex: index1 },
                    line2Data: { ...line2, newEndPoint: p2Trim, cornerIndex: index2 },
                    bezier: { type: 'path', points: [p1Trim, corner, p2Trim], color: '#e74c3c' }, 
                };
            }

            function applyFillet(filletData) {
                if (!filletData) return;
                const { line1Data, line2Data, bezier } = filletData;

                const newPoints1 = [];
                if (line1Data.cornerIndex === 0) { 
                    newPoints1.push(bezier.points[0]); 
                    for (let i = 1; i < line1Data.points.length; i++) newPoints1.push(line1Data.points[i]);
                } else { 
                    for (let i = 0; i < line1Data.cornerIndex; i++) newPoints1.push(line1Data.points[i]);
                    newPoints1.push(bezier.points[0]); 
                }

                const newPoints2 = [];
                if (line2Data.cornerIndex === 0) { 
                    newPoints2.push(bezier.points[2]); 
                    for (let i = 1; i < line2Data.points.length; i++) newPoints2.push(line2Data.points[i]);
                } else { 
                    for (let i = 0; i < line2Data.cornerIndex; i++) newPoints2.push(line2Data.points[i]);
                    newPoints2.push(bezier.points[2]); 
                }

                const indicesToRemove = new Set([line1Data.index, line2Data.index]);
                allPaths = allPaths.filter((path, index) => !indicesToRemove.has(index));

                if (newPoints1.length >= 2) allPaths.push({ type: 'line', points: newPoints1, color: line1Data.color || '#333' });
                if (newPoints2.length >= 2) allPaths.push({ type: 'line', points: newPoints2, color: line2Data.color || '#333' });
                allPaths.push(bezier); 

                selectedPaths = [];
                statusBar.textContent = 'Fillet created successfully!';
                render();
            }

            // Helper function for Catmull-Rom to get points, duplicating ends
            function getSplinePoint(pointsArray, index) {
                if (index < 0) return pointsArray[0];
                if (index >= pointsArray.length) return pointsArray[pointsArray.length - 1];
                return pointsArray[index];
            }

            function drawPaths() {
                allPaths.forEach((path, pathIndex) => {
                    if (!path.points || path.points.length < 1) return;
                  
                    const isSelected = selectedPaths.some(sp => sp.path.index === pathIndex); 
                    ctx.beginPath();
                    ctx.strokeStyle = isSelected ? '#ff9800' : (path.color || '#333');
                    ctx.lineWidth = (isSelected ? 3 : 2); 

                    ctx.moveTo(path.points[0].x, path.points[0].y);

                    if (path.type === 'line' || path.type === 'polyline') {
                        if (path.points.length >= 2) {
                            for(let i = 1; i < path.points.length; i++) ctx.lineTo(path.points[i].x, path.points[i].y);
                        }
                    } else if (path.type === 'path' && path.points.length === 3) { 
                        ctx.quadraticCurveTo(path.points[1].x, path.points[1].y, path.points[2].x, path.points[2].y);
                    } else if (path.type === 'arc' && path.points.length >= 3) {
                        const p1 = path.points[0], p2 = path.points[1], p3 = path.points[2];
                        const ax = p1.x, ay = p1.y, bx = p2.x, by = p2.y, cx = p3.x, cy = p3.y;
                        const D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
                        if (Math.abs(D) < 1e-6) { ctx.lineTo(cx, cy); }
                        else {
                            const K = (ax*ax + ay*ay), L = (bx*bx + by*by), M = (cx*cx + cy*cy);
                            const centerX = (K * (by - cy) + L * (cy - ay) + M * (ay - by)) / D;
                            const centerY = (K * (cx - bx) + L * (ax - cx) + M * (bx - ax)) / D;
                            const radius = Math.hypot(ax - centerX, ay - centerY);
                            const startAngle = Math.atan2(ay - centerY, ax - centerX);
                            const endAngle = Math.atan2(cy - centerY, cx - centerX);
                            const cross_product_orientation = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
                            ctx.arc(centerX, centerY, radius, startAngle, endAngle, cross_product_orientation < 0);
                        }
                    } else if ((path.type === 'spline3' || path.type === 'spline5') && path.points.length >= 2) {
                        // Interpolating Catmull-Rom spline
                        if (path.points.length === 2) {
                             ctx.lineTo(path.points[1].x, path.points[1].y);
                        } else {
                            // ctx.moveTo is already called with path.points[0]
                            for (let i = 0; i < path.points.length - 1; i++) {
                                const p0 = getSplinePoint(path.points, i - 1);
                                const p1 = getSplinePoint(path.points, i);     // Current segment's start
                                const p2 = getSplinePoint(path.points, i + 1); // Current segment's end
                                const p3 = getSplinePoint(path.points, i + 2);
                
                                // Calculate control points for cubic Bezier segment from p1 to p2
                                const cp1x = p1.x + (p2.x - p0.x) / 6;
                                const cp1y = p1.y + (p2.y - p0.y) / 6;
                
                                const cp2x = p2.x - (p3.x - p1.x) / 6;
                                const cp2y = p2.y - (p3.y - p1.y) / 6;
                                
                                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                            }
                        }
                    }
                    ctx.stroke();
                });
            }

            function drawPreview() {
                if (!isCoordMode && currentPath.length > 0 && tempPoint) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1; 
                    ctx.setLineDash([5, 3]);
                    const lastPoint = currentPath[currentPath.length - 1];
                    let previewX = tempPoint.x; let previewY = tempPoint.y;

                    if (orthoMode && (activeTool === 'line-tool' || activeTool === 'polyline-tool')) {
                         const dx = Math.abs(tempPoint.x - lastPoint.x);
                         const dy = Math.abs(tempPoint.y - lastPoint.y);
                         if (dx < dy) previewX = lastPoint.x; else previewY = lastPoint.y;
                    }

                    ctx.moveTo(lastPoint.x, lastPoint.y);
                    if (activeTool === 'arc-tool' && currentPath.length === 2) {
                        const p1 = currentPath[0], p2 = currentPath[1], p3 = {x: previewX, y: previewY};
                        const ax = p1.x, ay = p1.y, bx = p2.x, by = p2.y, cx = p3.x, cy = p3.y;
                        const D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
                        if (Math.abs(D) > 1e-6) {
                            const K = (ax*ax + ay*ay), L = (bx*bx + by*by), M = (cx*cx + cy*cy);
                            const centerX = (K * (by - cy) + L * (cy - ay) + M * (ay - by)) / D;
                            const centerY = (K * (cx - bx) + L * (ax - cx) + M * (bx - ax)) / D;
                            const radius = Math.hypot(ax - centerX, ay - centerY);
                            const startAngle = Math.atan2(ay - centerY, ax - centerX);
                            const endAngle = Math.atan2(cy - centerY, cx - centerX);
                            const cross_product_orientation = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
                            ctx.arc(centerX, centerY, radius, startAngle, endAngle,  cross_product_orientation < 0);
                        } else { ctx.lineTo(previewX, previewY); }
                    } else if ((activeTool === 'spline3-tool' || activeTool === 'spline5-tool') && currentPath.length >= 1) {
                        // Preview for Catmull-Rom: just a line to the next point for simplicity
                        // Or, if currentPath has enough points, could preview the next Bezier segment
                        if (currentPath.length === 1) {
                            ctx.lineTo(previewX, previewY); // Line from P0 to P1 (mouse)
                        } else {
                            // We have P_n-1 (lastPoint), P_n (previewX, previewY). Need P_n-2 and P_n+1 (mouse again?)
                            const tempFullPath = [...currentPath, {x: previewX, y: previewY}];
                            if (tempFullPath.length >= 2) {
                                // Draw last segment of the potential spline
                                const i = tempFullPath.length - 2; // index of lastPoint in tempFullPath
                                const p0 = getSplinePoint(tempFullPath, i - 1);
                                const p1 = getSplinePoint(tempFullPath, i);     // lastPoint
                                const p2 = getSplinePoint(tempFullPath, i + 1); // {x: previewX, y: previewY}
                                const p3 = getSplinePoint(tempFullPath, i + 2); // also {x: previewX, y: previewY}
                                
                                const cp1x = p1.x + (p2.x - p0.x) / 6;
                                const cp1y = p1.y + (p2.y - p0.y) / 6;
                                const cp2x = p2.x - (p3.x - p1.x) / 6;
                                const cp2y = p2.y - (p3.y - p1.y) / 6;
                                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                            } else {
                                ctx.lineTo(previewX, previewY);
                            }
                        }
                    } else { ctx.lineTo(previewX, previewY); }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            function drawSnapIndicator() {
                if (!isCoordMode && snapPoint) {
                    ctx.beginPath();
                    ctx.lineWidth = 1.5; 
                    const size = 6; 
                    if (snapPoint.type === 'endpoint') {
                        ctx.strokeStyle = '#007bff'; 
                        ctx.strokeRect(snapPoint.x - size/2, snapPoint.y - size/2, size, size); 
                    } else if (snapPoint.type === 'midpoint') {
                        ctx.strokeStyle = '#28a745'; 
                        ctx.moveTo(snapPoint.x, snapPoint.y - size/1.5);
                        ctx.lineTo(snapPoint.x + size/1.5, snapPoint.y + size/3);
                        ctx.lineTo(snapPoint.x - size/1.5, snapPoint.y + size/3);
                        ctx.closePath();
                    } else if (snapPoint.type === 'intersection') {
                        ctx.strokeStyle = '#dc3545'; 
                        ctx.moveTo(snapPoint.x - size/2, snapPoint.y - size/2);
                        ctx.lineTo(snapPoint.x + size/2, snapPoint.y + size/2);
                        ctx.moveTo(snapPoint.x + size/2, snapPoint.y - size/2);
                        ctx.lineTo(snapPoint.x - size/2, snapPoint.y + size/2);
                    } else if (snapPoint.type === 'grid') {
                        ctx.strokeStyle = '#ffc107'; 
                        ctx.beginPath(); 
                        ctx.arc(snapPoint.x, snapPoint.y, size/2, 0, Math.PI * 2); 
                    }
                    ctx.stroke();
                }
            }

            window.render = function() { 
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                drawGrid();
                drawPaths();
                drawPreview();
                drawSnapIndicator();
                if (!isCoordMode && tempPoint) {
                    const gridPoint = canvasToGrid(tempPoint.x, tempPoint.y);
                    coordsDisplay.textContent = `${gridPoint.x.toFixed(2)}, ${gridPoint.y.toFixed(2)}`;
                } else if (!isCoordMode && !tempPoint) { 
                     const centerGridPoint = canvasToGrid(canvas.width / 2, canvas.height / 2);
                     coordsDisplay.textContent = `${centerGridPoint.x.toFixed(2)}, ${centerGridPoint.y.toFixed(2)}`; 
                }
            }

            function showCoordInput() {
                coordInputContainer.innerHTML = ''; 
                let pointsNeeded = 0; let instructionText = "";
                switch (activeTool) {
                    case 'line-tool': pointsNeeded = currentPath.length === 0 ? 2 : 1; instructionText = currentPath.length === 0 ? 'Line: Enter start & end points.' : 'Line: Enter end point.'; break;
                    case 'polyline-tool': pointsNeeded = 1; instructionText = currentPath.length === 0 ? 'Polyline: Enter first point.' : 'Polyline: Enter next point.'; break;
                    case 'arc-tool': pointsNeeded = 3 - currentPath.length; instructionText = `Arc: Enter point ${currentPath.length + 1} of 3.`; break;
                    case 'spline3-tool': pointsNeeded = (currentPath.length === 0 && activeTool === 'spline3-tool') ? 4 : (activeTool === 'spline3-tool' ? (4-currentPath.length) : 1); instructionText = `Spline3: Enter point ${currentPath.length + 1}. Total ${4} points for auto-finish.`; break;
                    case 'spline5-tool': pointsNeeded = (currentPath.length === 0 && activeTool === 'spline5-tool') ? 6 : (activeTool === 'spline5-tool' ? (6-currentPath.length) : 1); instructionText = `Spline5: Enter point ${currentPath.length + 1}. Total ${6} points for auto-finish.`; break;
                    default: coordInputContainer.style.display = 'none'; return;
                }
                if (activeTool === 'polyline-tool' && currentPath.length > 0) pointsNeeded = 1;
                if ((activeTool === 'spline3-tool' || activeTool === 'spline5-tool') && currentPath.length > 0) {
                    if (activeTool === 'spline3-tool' && currentPath.length < 4) pointsNeeded = 1;
                    else if (activeTool === 'spline5-tool' && currentPath.length < 6) pointsNeeded = 1;
                    else pointsNeeded = 0; 
                }

                statusBar.textContent = instructionText;
                if (pointsNeeded <=0 && activeTool !== 'polyline-tool' && activeTool !== 'spline3-tool' && activeTool !== 'spline5-tool') { 
                    coordInputContainer.style.display = 'none'; return; 
                }
                if (pointsNeeded <= 0 && (activeTool === 'spline3-tool' && currentPath.length >= 4) || (activeTool === 'spline5-tool' && currentPath.length >= 6)) {
                    // No more points needed, but show finish button
                }


                coordInputContainer.style.display = 'flex';
                coordInputContainer.style.flexDirection = 'row'; coordInputContainer.style.flexWrap = 'wrap';     
                coordInputContainer.style.justifyContent = 'center'; coordInputContainer.style.alignItems = 'center';   
                coordInputContainer.style.gap = '15px'; 

                for (let i = 0; i < pointsNeeded; i++) {
                    const div = document.createElement('div'); div.style.display = 'flex'; div.style.alignItems = 'center'; div.style.gap = '5px'; 
                    const pointLabel = currentPath.length + i + 1;
                    const labelSpan = document.createElement('span'); labelSpan.textContent = `P${pointLabel}:`;
                    const inputX = document.createElement('input'); inputX.type = 'number'; inputX.className = 'coord-input'; inputX.id = `coordX${i}`; inputX.placeholder = 'X (m)'; inputX.step = 'any'; 
                    const inputY = document.createElement('input'); inputY.type = 'number'; inputY.className = 'coord-input'; inputY.id = `coordY${i}`; inputY.placeholder = 'Y (m)'; inputY.step = 'any'; 
                    div.appendChild(labelSpan); div.appendChild(inputX); div.appendChild(inputY);
                    coordInputContainer.appendChild(div);
                }
                
                if (pointsNeeded > 0 || ( (activeTool === 'polyline-tool' || activeTool === 'spline3-tool' || activeTool === 'spline5-tool') && currentPath.length > 0)) {
                    if (pointsNeeded > 0 && document.getElementById('coordX0')) { 
                        document.getElementById('coordX0').focus(); 
                        const submitBtn = document.createElement('button'); submitBtn.className = 'coord-submit'; submitBtn.textContent = 'Add Point(s)';
                        const handleInputSubmit = () => {
                            const enteredCanvasPoints = [];
                            for (let i = 0; i < pointsNeeded; i++) { 
                                const xInput = document.getElementById(`coordX${i}`); const yInput = document.getElementById(`coordY${i}`);
                                if (!xInput || !yInput) { console.error("Input field not found"); continue; }
                                const xVal = parseFloat(xInput.value); const yVal = parseFloat(yInput.value);
                                if (isNaN(xVal) || isNaN(yVal)) { statusBar.textContent = 'Invalid coordinate input.'; return; }
                                enteredCanvasPoints.push(gridToCanvas(xVal, yVal)); 
                            }
                            enteredCanvasPoints.forEach(p => currentPath.push(p));
                            let toolFinished = false;
                            if (activeTool === 'line-tool' && currentPath.length >= 2) toolFinished = true;
                            else if (activeTool === 'arc-tool' && currentPath.length >= 3) toolFinished = true;
                            else if (activeTool === 'spline3-tool' && currentPath.length >= 4) toolFinished = true;
                            else if (activeTool === 'spline5-tool' && currentPath.length >= 6) toolFinished = true;
                            if (toolFinished) {
                                allPaths.push({ type: activeTool.replace('-tool', ''), points: [...currentPath], color: '#333' });
                                statusBar.textContent = `${activeTool.replace('-tool', '')} created.`; currentPath = []; 
                            } else if (activeTool === 'polyline-tool') {
                                statusBar.textContent = `Polyline: Point ${currentPath.length} added. Add more or Finish.`;
                            } else if (activeTool === 'spline3-tool' || activeTool === 'spline5-tool') {
                                const maxPts = activeTool === 'spline3-tool' ? 4 : 6;
                                statusBar.textContent = `${activeTool.replace('-tool','')}: Point ${currentPath.length}/${maxPts} added. Add more or Finish.`;
                            }
                            render(); showCoordInput(); 
                        };
                        submitBtn.addEventListener('click', handleInputSubmit);
                        coordInputContainer.appendChild(submitBtn);
                        const lastYInputId = `coordY${pointsNeeded - 1}`; const lastYInputElement = document.getElementById(lastYInputId);
                        if (lastYInputElement) {
                            lastYInputElement.addEventListener('keydown', (event) => { if (event.key === 'Enter') { event.preventDefault(); handleInputSubmit(); }});
                        }
                    }
                    if ((activeTool === 'polyline-tool' || activeTool === 'spline3-tool' || activeTool === 'spline5-tool') && currentPath.length > 0) {
                        const finishBtn = document.createElement('button'); finishBtn.className = 'coord-submit'; finishBtn.textContent = `Finish ${activeTool.replace('-tool', '')}`;
                        finishBtn.addEventListener('click', () => {
                            const minPoints = (activeTool === 'polyline-tool' || activeTool === 'spline3-tool' || activeTool === 'spline5-tool') ? 2 : 0; 
                            if (currentPath.length >= minPoints) {
                                allPaths.push({ type: activeTool.replace('-tool', ''), points: [...currentPath], color: '#333' });
                                statusBar.textContent = `${activeTool.replace('-tool', '')} finished.`; currentPath = []; render(); showCoordInput(); 
                            } else { statusBar.textContent = `${activeTool.replace('-tool', '')} needs at least ${minPoints} points to finish.`; }
                        });
                        coordInputContainer.appendChild(finishBtn);
                    }
                }
                if (coordInputContainer.hasChildNodes()) coordInputContainer.style.display = 'flex'; else coordInputContainer.style.display = 'none';
            }

            function hideCoordInput() {
                coordInputContainer.innerHTML = ''; coordInputContainer.style.display = 'none';
                if (activeTool !== 'fillet-tool' && !activeTool.startsWith('zoom-') && activeTool !== 'reset-view-tool' &&
                    activeTool !== 'save-tool' && activeTool !== 'clear-tool' && activeTool !== 'clear-data-tool') {
                     statusBar.textContent = `${activeTool.replace('-tool', '')} tool active. Click on canvas.`;
                }
            }

            tools.forEach(tool => {
                tool.addEventListener('click', () => {
                    if (tool.id.startsWith('zoom-') || tool.id === 'reset-view-tool') {
                        if (tool.id === 'zoom-in-tool') zoomCanvasView(true);
                        else if (tool.id === 'zoom-out-tool') zoomCanvasView(false);
                        else if (tool.id === 'reset-view-tool') resetView();
                        return; 
                    }

                    tools.forEach(t => t.classList.remove('active'));
                    tool.classList.add('active');
                    activeTool = tool.id;
                    currentPath = []; selectedPaths = []; 

                    if (activeTool === 'fillet-tool') {
                        filletControls.style.display = 'flex';
                        statusBar.textContent = 'Fillet tool selected. Select two connected lines.';
                        canvas.style.cursor = 'default';
                        if(isCoordMode) { coordToggle.checked = false; isCoordMode = false; canvas.style.pointerEvents = 'auto'; hideCoordInput(); }
                    } else {
                        filletControls.style.display = 'none';
                        canvas.style.cursor = 'crosshair';
                        if (activeTool === 'clear-tool') { allPaths = []; render(); statusBar.textContent = 'Canvas cleared.'; }
                        else if (activeTool === 'clear-data-tool') { allPaths = []; localStorage.removeItem('drawingPaths'); render(); statusBar.textContent = 'All drawing data cleared.';}
                        else if (activeTool === 'save-tool') {
                            const realMapWidthPx = mapWidth;       
                            const realMapHeightPx = mapHeight;     

                            const tempCanvasSave = document.createElement('canvas');
                            tempCanvasSave.width = realMapWidthPx;
                            tempCanvasSave.height = realMapHeightPx;
                            const tempCtxSave = tempCanvasSave.getContext('2d');
                            
                            function realToImagePixelCoords(realX, realY) {
                                const px = (realX - origin_x) / resolution_x;
                                const py = realMapHeightPx - ((realY - origin_y) / resolution_y); 
                                return { x: px, y: py };
                            }
                            tempCtxSave.strokeStyle = '#000000'; tempCtxSave.lineWidth = 1;     

                            allPaths.forEach(path => {
                                if (!path.points || path.points.length === 0) return; 
                                
                                const realWorldPoints = path.points.map(p_canvas => canvasToGrid(p_canvas.x, p_canvas.y)); 

                                if (path.type === 'line' && realWorldPoints.length < 2) return;
                                if (path.type === 'polyline' && realWorldPoints.length < 2) return;
                                if (path.type === 'arc' && realWorldPoints.length < 3) return;
                                if (path.type === 'path' && realWorldPoints.length < 3) return; 
                                if ((path.type === 'spline3' || path.type === 'spline5') && realWorldPoints.length < 2) return;


                                tempCtxSave.beginPath();
                                const startPx = realToImagePixelCoords(realWorldPoints[0].x, realWorldPoints[0].y);
                                tempCtxSave.moveTo(startPx.x, startPx.y);

                                if (path.type === 'line' || path.type === 'polyline') {
                                    for (let i = 1; i < realWorldPoints.length; i++) {
                                        const pPx = realToImagePixelCoords(realWorldPoints[i].x, realWorldPoints[i].y);
                                        tempCtxSave.lineTo(pPx.x, pPx.y);
                                    }
                                } else if (path.type === 'path' && realWorldPoints.length === 3) { 
                                    const cpPx = realToImagePixelCoords(realWorldPoints[1].x, realWorldPoints[1].y);
                                    const endPx = realToImagePixelCoords(realWorldPoints[2].x, realWorldPoints[2].y);
                                    tempCtxSave.quadraticCurveTo(cpPx.x, cpPx.y, endPx.x, endPx.y);
                                } else if (path.type === 'arc' && realWorldPoints.length === 3) {
                                    const p1_real = realWorldPoints[0]; const p2_real = realWorldPoints[1]; const p3_real = realWorldPoints[2];
                                    const p1_px = realToImagePixelCoords(p1_real.x, p1_real.y);
                                    const p2_px = realToImagePixelCoords(p2_real.x, p2_real.y);
                                    const p3_px = realToImagePixelCoords(p3_real.x, p3_real.y);
                                    const D_px = 2 * (p1_px.x * (p2_px.y - p3_px.y) + p2_px.x * (p3_px.y - p1_px.y) + p3_px.x * (p1_px.y - p2_px.y));
                                    if (Math.abs(D_px) > 1e-6) {
                                        const K_px = p1_px.x*p1_px.x + p1_px.y*p1_px.y; const L_px = p2_px.x*p2_px.x + p2_px.y*p2_px.y; const M_px = p3_px.x*p3_px.x + p3_px.y*p3_px.y;
                                        const centerX_px = (K_px*(p2_px.y - p3_px.y) + L_px*(p3_px.y - p1_px.y) + M_px*(p1_px.y - p2_px.y)) / D_px;
                                        const centerY_px = (K_px*(p3_px.x - p2_px.x) + L_px*(p1_px.x - p3_px.x) + M_px*(p2_px.x - p1_px.x)) / D_px;
                                        const radius_px = Math.hypot(p1_px.x - centerX_px, p1_px.y - centerY_px);
                                        const startAngle_px = Math.atan2(p1_px.y - centerY_px, p1_px.x - centerX_px);
                                        const endAngle_px = Math.atan2(p3_px.y - centerY_px, p3_px.x - centerX_px);
                                        const cross_prod_orient_px = (p2_px.x - p1_px.x) * (p3_px.y - p1_px.y) - (p2_px.y - p1_px.y) * (p3_px.x - p1_px.x);
                                        tempCtxSave.arc(centerX_px, centerY_px, radius_px, startAngle_px, endAngle_px, cross_prod_orient_px < 0);
                                    } else { tempCtxSave.lineTo(p3_px.x, p3_px.y); }
                                } else if ((path.type === 'spline3' || path.type === 'spline5') && realWorldPoints.length >= 2) {
                                    const imagePoints = realWorldPoints.map(p => realToImagePixelCoords(p.x, p.y));
                                    
                                    if (imagePoints.length === 2) { 
                                        tempCtxSave.lineTo(imagePoints[1].x, imagePoints[1].y); 
                                    } else { 
                                        for (let i = 0; i < imagePoints.length - 1; i++) {
                                            const p0_img = getSplinePoint(imagePoints, i - 1); 
                                            const p1_img = getSplinePoint(imagePoints, i);
                                            const p2_img = getSplinePoint(imagePoints, i + 1);
                                            const p3_img = getSplinePoint(imagePoints, i + 2);
                            
                                            const cp1x_img = p1_img.x + (p2_img.x - p0_img.x) / 6;
                                            const cp1y_img = p1_img.y + (p2_img.y - p0_img.y) / 6;
                            
                                            const cp2x_img = p2_img.x - (p3_img.x - p1_img.x) / 6;
                                            const cp2y_img = p2_img.y - (p3_img.y - p1_img.y) / 6;
                                            
                                            tempCtxSave.bezierCurveTo(cp1x_img, cp1y_img, cp2x_img, cp2y_img, p2_img.x, p2_img.y);
                                        }
                                    }
                                }
                                tempCtxSave.stroke();
                            });
                            const pathImageData = tempCanvasSave.toDataURL('image/png');
                            fetch('/save_path_image', { method: 'POST', body: JSON.stringify({ image: pathImageData }), headers: { 'Content-Type': 'application/json' }});
                            
                            const realWorldPathsForJson = allPaths.map(path => {
                                let pathDataToSave = { type: path.type, color: path.color || '#333' };

                                const realWorldPointsObjects = path.points ? path.points.map(point => {
                                    const realCoord = canvasToGrid(point.x, point.y);
                                    return { x: parseFloat(realCoord.x.toFixed(3)), y: parseFloat(realCoord.y.toFixed(3)) };
                                }) : [];

                                if (path.type === 'line') {
                                    if (realWorldPointsObjects.length === 2) {
                                        pathDataToSave.x = [realWorldPointsObjects[0].x, realWorldPointsObjects[1].x];
                                        pathDataToSave.y = [realWorldPointsObjects[0].y, realWorldPointsObjects[1].y];
                                    } else {
                                        pathDataToSave.points = realWorldPointsObjects;
                                        pathDataToSave.error = "Line requires 2 points for x/y array format.";
                                    }
                                } else if (path.type === 'arc') {
                                    if (realWorldPointsObjects.length === 3) {
                                        const [p1_real, p2_real, p3_real] = realWorldPointsObjects;
                                        pathDataToSave.start_x = p1_real.x; pathDataToSave.start_y = p1_real.y;
                                        pathDataToSave.end_x = p3_real.x; pathDataToSave.end_y = p3_real.y;
                                        const D_real = 2 * (p1_real.x * (p2_real.y - p3_real.y) + p2_real.x * (p3_real.y - p1_real.y) + p3_real.x * (p1_real.y - p2_real.y));
                                        if (Math.abs(D_real) < 1e-9) {
                                            pathDataToSave.warning = "Collinear arc points.";
                                            pathDataToSave.collinear_arc_points = realWorldPointsObjects;
                                        } else {
                                            const K_real = (p1_real.x**2 + p1_real.y**2), L_real = (p2_real.x**2 + p2_real.y**2), M_real = (p3_real.x**2 + p3_real.y**2);
                                            pathDataToSave.center_x = parseFloat(((K_real * (p2_real.y - p3_real.y) + L_real * (p3_real.y - p1_real.y) + M_real * (p1_real.y - p2_real.y)) / D_real).toFixed(3));
                                            pathDataToSave.center_y = parseFloat(((K_real * (p3_real.x - p2_real.x) + L_real * (p1_real.x - p3_real.x) + M_real * (p2_real.x - p1_real.x)) / D_real).toFixed(3));
                                            pathDataToSave.radius = parseFloat(Math.hypot(p1_real.x - pathDataToSave.center_x, p1_real.y - pathDataToSave.center_y).toFixed(3));
                                            pathDataToSave.start_angle = parseFloat(Math.atan2(p1_real.y - pathDataToSave.center_y, p1_real.x - pathDataToSave.center_x).toFixed(3));
                                            pathDataToSave.end_angle = parseFloat(Math.atan2(p3_real.y - pathDataToSave.center_y, p3_real.x - pathDataToSave.center_x).toFixed(3));
                                        }
                                    } else {
                                        pathDataToSave.points = realWorldPointsObjects; 
                                        pathDataToSave.error = "Arc requires 3 points.";
                                    }
                                } else if (path.type === 'spline3' || path.type === 'spline5') {
                                    pathDataToSave.points = realWorldPointsObjects.map(p => [p.x, p.y]);
                                } else if (path.type === 'polyline' || path.type === 'path') { 
                                    pathDataToSave.points = realWorldPointsObjects;
                                    if (realWorldPointsObjects.length > 0) {
                                        pathDataToSave.startPoint = realWorldPointsObjects[0];
                                        pathDataToSave.endPoint = realWorldPointsObjects[realWorldPointsObjects.length - 1];
                                        if (path.type === 'path' && realWorldPointsObjects.length === 3) { 
                                            pathDataToSave.endPoint = realWorldPointsObjects[2];
                                        }
                                    }
                                } else {
                                    pathDataToSave.points = realWorldPointsObjects;
                                    if (realWorldPointsObjects.length > 0) {
                                        pathDataToSave.startPoint = realWorldPointsObjects[0];
                                        pathDataToSave.endPoint = realWorldPointsObjects.length > 1 ? realWorldPointsObjects[realWorldPointsObjects.length - 1] : realWorldPointsObjects[0];
                                    }
                                }
                                return pathDataToSave;
                            });

                            fetch('/save_path_json', { method: 'POST', body: JSON.stringify({ paths: realWorldPathsForJson }), headers: { 'Content-Type': 'application/json' }})
                                .then(response => response.json()) 
                                .then(data => {
                                    console.log('Save JSON response:', data);
                                    statusBar.textContent = 'Image (transparent bg) and JSON saved.';
                                })
                                .catch(error => {
                                    console.error('Error saving JSON:', error);
                                    statusBar.textContent = 'Image saved. Error saving JSON.';
                                });
                        } else { 
                            if (isCoordMode) showCoordInput();
                            else statusBar.textContent = `${activeTool.replace('-tool', '')} tool selected. Click to start drawing.`;
                        }
                    }
                    render();
                });
            });

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 1) { 
                    isPanning = true;
                    lastPanPoint = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                    e.preventDefault();
                    return; 
                }
                if (isCoordMode) return;

                const rect = canvas.getBoundingClientRect();
                let x = e.clientX - rect.left;
                let y = e.clientY - rect.top;

                if (snapPoint) { x = snapPoint.x; y = snapPoint.y; }
                if (orthoMode && currentPath.length > 0 && (activeTool === 'line-tool' || activeTool === 'polyline-tool')) {
                    const last = currentPath[currentPath.length - 1];
                    const dx = Math.abs(x - last.x); const dy = Math.abs(y - last.y);
                    if (dx < dy) x = last.x; else y = last.y; 
                }

                if (activeTool === 'fillet-tool') {
                    const nearest = findNearestLine(x, y);
                    if (nearest) {
                        const isAlreadySelected = selectedPaths.some(sp => sp.path.index === nearest.path.index);
                        if (isAlreadySelected) selectedPaths = selectedPaths.filter(sp => sp.path.index !== nearest.path.index);
                        else {
                            if (selectedPaths.length < 2) selectedPaths.push(nearest); 
                            if (selectedPaths.length === 2) {
                                const filletData = calculateFillet();
                                if (filletData) applyFillet(filletData); else selectedPaths = [];
                            }
                        }
                    }
                } else if (activeTool.startsWith('zoom-') || activeTool === 'reset-view-tool' ||
                           activeTool === 'clear-tool' || activeTool === 'clear-data-tool' || activeTool === 'save-tool') {
                    return; 
                } else { 
                    if (e.button === 2) { // Right click
                        if (currentPath.length >= 2 && (activeTool === 'polyline-tool' || activeTool === 'spline3-tool' || activeTool === 'spline5-tool')) {
                            allPaths.push({ type: activeTool.replace('-tool', ''), points: [...currentPath], color: '#333' });
                            currentPath = []; statusBar.textContent = `${activeTool.replace('-tool', '')} completed.`;
                        } else { currentPath = []; statusBar.textContent = `Drawing cancelled for ${activeTool.replace('-tool', '')}.`; }
                        drawing = false; 
                        render(); 
                        return; 
                    }

                    currentPath.push({ x, y }); 
                    drawing = true; 

                    if (activeTool === 'line-tool') {
                        if (currentPath.length === 1) statusBar.textContent = 'Line: Click to set end point.';
                        else if (currentPath.length === 2) {
                            allPaths.push({ type: 'line', points: [...currentPath], color: '#333' });
                            currentPath = []; drawing = false; statusBar.textContent = 'Line completed.';
                        }
                    } else if (activeTool === 'polyline-tool') {
                        statusBar.textContent = `Polyline: Point ${currentPath.length} added. Click for next, or right-click to finish.`;
                    } else if (activeTool === 'arc-tool') {
                         statusBar.textContent = `Arc: Point ${currentPath.length}/3. Click for next point.`;
                        if (currentPath.length === 3) {
                            allPaths.push({ type: 'arc', points: [...currentPath], color: '#333' });
                            currentPath = []; drawing = false; statusBar.textContent = 'Arc completed.';
                        }
                    } else if (activeTool === 'spline3-tool') {
                        statusBar.textContent = `Spline3: Point ${currentPath.length}/4. Click for next, or right-click to finish.`;
                        if (currentPath.length === 4) { 
                            allPaths.push({ type: 'spline3', points: [...currentPath], color: '#333' });
                            currentPath = []; drawing = false; statusBar.textContent = 'Spline3 completed.';
                        }
                    } else if (activeTool === 'spline5-tool') {
                         statusBar.textContent = `Spline5: Point ${currentPath.length}/6. Click for next, or right-click to finish.`;
                        if (currentPath.length === 6) { 
                            allPaths.push({ type: 'spline5', points: [...currentPath], color: '#333' });
                            currentPath = []; drawing = false; statusBar.textContent = 'Spline5 completed.';
                        }
                    }
                }
                render();
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    const dx = e.clientX - lastPanPoint.x;
                    const dy = e.clientY - lastPanPoint.y;
                    viewOffsetX += dx;
                    viewOffsetY += dy;
                    lastPanPoint = { x: e.clientX, y: e.clientY };
                    render();
                    return; 
                }
                if (isCoordMode) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                snapPoint = findSnapPoint(x, y);
                tempPoint = snapPoint ? { x: snapPoint.x, y: snapPoint.y } : { x, y };
                
                if (drawing && orthoMode && currentPath.length > 0 && (activeTool === 'line-tool' || activeTool === 'polyline-tool')) {
                    const last = currentPath[currentPath.length - 1];
                    const dx = Math.abs(tempPoint.x - last.x); const dy = Math.abs(tempPoint.y - last.y);
                    if (dx < dy) tempPoint.x = last.x; else tempPoint.y = last.y; 
                }
                render();
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 1 && isPanning) {
                    isPanning = false;
                    const currentToolButton = document.querySelector('.tool-button.active');
                    if (currentToolButton && currentToolButton.id === 'fillet-tool') {
                         canvas.style.cursor = 'default';
                    } else if (activeTool.startsWith('zoom-') || activeTool === 'reset-view-tool') {
                        canvas.style.cursor = 'default'; 
                    }
                    else {
                         canvas.style.cursor = 'crosshair';
                    }
                }
            });

            canvas.addEventListener('mouseleave', () => {
                if (isPanning) {
                    isPanning = false;
                    canvas.style.cursor = 'crosshair'; 
                }
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left; 
                const mouseY = e.clientY - rect.top;

                const mouseGridBefore = canvasToGrid(mouseX, mouseY); 

                const delta = e.deltaY < 0 ? ZOOM_SENSITIVITY : 1 / ZOOM_SENSITIVITY;
                const newViewScale = viewScale * delta;
                
                viewScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newViewScale));

                viewOffsetX = mouseX - (mouseGridBefore.x - origin_x) * viewScale;
                viewOffsetY = mouseY + (mouseGridBefore.y - origin_y) * viewScale;
                
                render();
            });
            
            function zoomCanvasView(zoomIn) { 
                const factor = ZOOM_SENSITIVITY;
                const zoomMultiplier = zoomIn ? factor : 1 / factor;

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const centerGridBefore = canvasToGrid(centerX, centerY);

                const newViewScale = viewScale * zoomMultiplier;
                viewScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newViewScale));

                viewOffsetX = centerX - (centerGridBefore.x - origin_x) * viewScale;
                viewOffsetY = centerY + (centerGridBefore.y - origin_y) * viewScale;
                render();
            }

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            document.getElementById('line-tool').click(); 
        }
    </script>
</body>
</html>